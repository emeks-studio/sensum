// Main reference: https://docs.midnight.network/develop/how-midnight-works/keeping-data-private
// Here for available functions: https://docs.midnight.network/develop/reference/compact/ledger-adt
// Here about types: https://docs.midnight.network/develop/reference/compact/lang-ref#types

include "std";

witness find_auth_path(pk: Bytes[32]): MerkleTreePath[10, Bytes[32]];
witness secret_key(): Bytes[32];

ledger {
  // TODO: We could have a set of "The Oracles" (in the context of sensum).
  // a.k.a The Oracle
  organizer: Cell[Bytes[32]];
  
  // HistoricMerkleTree[n,a]: A path in a depth `n` Merkle tree, leading to a leaf of type `a`
  // Ref. https://docs.midnight.network/develop/reference/compact/compact-std-library/exports#merkletreepath
  // TODO: review n meaning!
  authorizedCommitments: HistoricMerkleTree[10, Bytes[32]];
  authorizedNullifiers: Set[Bytes[32]];
  // TODO: Verify this works, also, is this just the hash Opaque["String"]? I'm confused.
  restrictedSensations: List[Opaque["string"]];

  constructor() {
    // ledger.organizer.write(organizer_public_key(secret_key()));
    ledger.organizer = organizer_public_key(secret_key());
  }
}

export circuit add_chosen_one(pk: Bytes[32]): Void {
  // assert ledger.organizer.read() == organizer_public_key(secret_key()) "You have no power here!";
  assert ledger.organizer == organizer_public_key(secret_key()) "You have no power here!";
  // TODO: Instead of receive a pk, we should witness one (Organizer desicion should be fair).
  const chosen_one = pk;
  // In case merkle tree is full, we reset it to default. Old tokens expired!
  if (ledger.authorizedCommitments.is_full())
    ledger.authorizedCommitments.reset_to_default();
    ledger.authorizedNullifiers.reset_to_default();
  ledger.authorizedCommitments.insert(pk);
}

export circuit newSensation(sensation: Opaque["string"]): Void{
  const sk = secret_key();
  const auth_path = find_auth_path(public_key(sk));
  assert ledger.authorizedCommitments.check_root(merkle_tree_path_root[10, Bytes[32]](auth_path))
    "You are not a chosen one!";
  const nul = nullifier(sk);
  assert !ledger.authorizedNullifiers.member(nul) "token already used!";
  ledger.authorizedNullifiers.insert(nul);
  ledger.restrictedSensations.push_front(sensation);
}

export circuit organizer_public_key(sk: Bytes[32]): Bytes[32] {
  return persistent_hash(pad(32, "organaizer-domain"), sk);
}

circuit public_key(sk: Bytes[32]): Bytes[32] {
  return persistent_hash(pad(32, "commitment-domain"), sk);
}

circuit nullifier(sk: Bytes[32]): Bytes[32] {
  return persistent_hash(pad(32, "nullifier-domain"), sk);
}

// FIXME: Review this crap! I think it won't work, given you can't remove elements from a merkle tree.
export circuit iWannaBeElected(): Void {
  const nul = nullifier(sk);
  assert ledger.authorizedNullifiers.member(nul) "you already are a chosen one, enjoy it!";
  ledger.authorizedNullifiers.remove(nul);
}